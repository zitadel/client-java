/*
 * Zitadel SDK
 * The Zitadel SDK is a convenience wrapper around the Zitadel APIs to assist you in integrating with your Zitadel environment. This SDK enables you to handle resources, settings, and configurations within the Zitadel platform.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.zitadel.api;

import com.fasterxml.jackson.core.type.TypeReference;
import com.zitadel.*;
import com.zitadel.model.*;

import java.util.*;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.12.0")
public class UserServiceApi extends BaseApi {

  public UserServiceApi() {
    super(Configuration.getDefaultApiClient());
  }

  public UserServiceApi(ApiClient apiClient) {
    super(apiClient);
  }

  /**
   * Create a new human user
   * Create/import a new user with the type human. The newly created user will get a verification email if either the email address is not marked as verified and you did not request the verification to be returned.
   *
   * @param body (required)
   * @return V2AddHumanUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddHumanUserResponse addHumanUser(V2AddHumanUserRequest body) throws ApiException {
    return this.addHumanUser(body, Collections.emptyMap());
  }


  /**
   * Create a new human user
   * Create/import a new user with the type human. The newly created user will get a verification email if either the email address is not marked as verified and you did not request the verification to be returned.
   *
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2AddHumanUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddHumanUserResponse addHumanUser(V2AddHumanUserRequest body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling addHumanUser");
    }

    // create path and map variables
    String localVarPath = "/v2/users/human";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2AddHumanUserResponse> localVarReturnType = new TypeReference<V2AddHumanUserResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Add link to an identity provider to an user
   * Add link to an identity provider to an user..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2AddIDPLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddIDPLinkResponse addIDPLink(String userId, UserServiceAddIDPLinkBody body) throws ApiException {
    return this.addIDPLink(userId, body, Collections.emptyMap());
  }


  /**
   * Add link to an identity provider to an user
   * Add link to an identity provider to an user..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2AddIDPLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddIDPLinkResponse addIDPLink(String userId, UserServiceAddIDPLinkBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling addIDPLink");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling addIDPLink");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/links"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2AddIDPLinkResponse> localVarReturnType = new TypeReference<V2AddIDPLinkResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Add OTP Email for a user
   * Add a new One-Time Password (OTP) Email factor to the authenticated user. OTP Email will enable the user to verify a OTP with the latest verified email. The email has to be verified to add the second factor..
   *
   * @param userId (required)
   * @return V2AddOTPEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddOTPEmailResponse addOTPEmail(String userId) throws ApiException {
    return this.addOTPEmail(userId, Collections.emptyMap());
  }


  /**
   * Add OTP Email for a user
   * Add a new One-Time Password (OTP) Email factor to the authenticated user. OTP Email will enable the user to verify a OTP with the latest verified email. The email has to be verified to add the second factor..
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2AddOTPEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddOTPEmailResponse addOTPEmail(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling addOTPEmail");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/otp_email"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2AddOTPEmailResponse> localVarReturnType = new TypeReference<V2AddOTPEmailResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Add OTP SMS for a user
   * Add a new One-Time Password (OTP) SMS factor to the authenticated user. OTP SMS will enable the user to verify a OTP with the latest verified phone number. The phone number has to be verified to add the second factor..
   *
   * @param userId (required)
   * @return V2AddOTPSMSResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddOTPSMSResponse addOTPSMS(String userId) throws ApiException {
    return this.addOTPSMS(userId, Collections.emptyMap());
  }


  /**
   * Add OTP SMS for a user
   * Add a new One-Time Password (OTP) SMS factor to the authenticated user. OTP SMS will enable the user to verify a OTP with the latest verified phone number. The phone number has to be verified to add the second factor..
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2AddOTPSMSResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddOTPSMSResponse addOTPSMS(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling addOTPSMS");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/otp_sms"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2AddOTPSMSResponse> localVarReturnType = new TypeReference<V2AddOTPSMSResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Create an invite code for a user
   * Create an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods.
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2CreateInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2CreateInviteCodeResponse createInviteCode(String userId, UserServiceCreateInviteCodeBody body) throws ApiException {
    return this.createInviteCode(userId, body, Collections.emptyMap());
  }


  /**
   * Create an invite code for a user
   * Create an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods.
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2CreateInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2CreateInviteCodeResponse createInviteCode(String userId, UserServiceCreateInviteCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling createInviteCode");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling createInviteCode");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/invite_code"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2CreateInviteCodeResponse> localVarReturnType = new TypeReference<V2CreateInviteCodeResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Create a passkey registration link for a user
   * Create a passkey registration link which includes a code and either return it or send it to the user..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2CreatePasskeyRegistrationLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2CreatePasskeyRegistrationLinkResponse createPasskeyRegistrationLink(String userId, UserServiceCreatePasskeyRegistrationLinkBody body) throws ApiException {
    return this.createPasskeyRegistrationLink(userId, body, Collections.emptyMap());
  }


  /**
   * Create a passkey registration link for a user
   * Create a passkey registration link which includes a code and either return it or send it to the user..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2CreatePasskeyRegistrationLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2CreatePasskeyRegistrationLinkResponse createPasskeyRegistrationLink(String userId, UserServiceCreatePasskeyRegistrationLinkBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling createPasskeyRegistrationLink");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling createPasskeyRegistrationLink");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys/registration_link"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2CreatePasskeyRegistrationLinkResponse> localVarReturnType = new TypeReference<V2CreatePasskeyRegistrationLinkResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Deactivate user
   * The state of the user will be changed to &#39;deactivated&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;deactivated&#39;. Use deactivate user when the user should not be able to use the account anymore, but you still need access to the user data..
   *
   * @param userId (required)
   * @return V2DeactivateUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2DeactivateUserResponse deactivateUser(String userId) throws ApiException {
    return this.deactivateUser(userId, Collections.emptyMap());
  }


  /**
   * Deactivate user
   * The state of the user will be changed to &#39;deactivated&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;deactivated&#39;. Use deactivate user when the user should not be able to use the account anymore, but you still need access to the user data..
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2DeactivateUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2DeactivateUserResponse deactivateUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling deactivateUser");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/deactivate"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2DeactivateUserResponse> localVarReturnType = new TypeReference<V2DeactivateUserResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Delete user
   * The state of the user will be changed to &#39;deleted&#39;. The user will not be able to log in anymore. Endpoints requesting this user will return an error &#39;User not found..
   *
   * @param userId (required)
   * @return V2DeleteUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2DeleteUserResponse deleteUser(String userId) throws ApiException {
    return this.deleteUser(userId, Collections.emptyMap());
  }


  /**
   * Delete user
   * The state of the user will be changed to &#39;deleted&#39;. The user will not be able to log in anymore. Endpoints requesting this user will return an error &#39;User not found..
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2DeleteUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2DeleteUserResponse deleteUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling deleteUser");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2DeleteUserResponse> localVarReturnType = new TypeReference<V2DeleteUserResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "DELETE",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * User by ID
   * Returns the full user object (human or machine) including the profile, email, etc..
   *
   * @param userId User ID of the user you like to get. (required)
   * @return V2GetUserByIDResponse
   * @throws ApiException if fails to make API call
   */
  public V2GetUserByIDResponse getUserByID(String userId) throws ApiException {
    return this.getUserByID(userId, Collections.emptyMap());
  }


  /**
   * User by ID
   * Returns the full user object (human or machine) including the profile, email, etc..
   *
   * @param userId            User ID of the user you like to get. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2GetUserByIDResponse
   * @throws ApiException if fails to make API call
   */
  public V2GetUserByIDResponse getUserByID(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling getUserByID");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2GetUserByIDResponse> localVarReturnType = new TypeReference<V2GetUserByIDResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "GET",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * MFA Init Skipped
   * Update the last time the user has skipped MFA initialization. The server timestamp is used.
   *
   * @param userId (required)
   * @return V2HumanMFAInitSkippedResponse
   * @throws ApiException if fails to make API call
   */
  public V2HumanMFAInitSkippedResponse humanMFAInitSkipped(String userId) throws ApiException {
    return this.humanMFAInitSkipped(userId, Collections.emptyMap());
  }


  /**
   * MFA Init Skipped
   * Update the last time the user has skipped MFA initialization. The server timestamp is used.
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2HumanMFAInitSkippedResponse
   * @throws ApiException if fails to make API call
   */
  public V2HumanMFAInitSkippedResponse humanMFAInitSkipped(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling humanMFAInitSkipped");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/mfa_init_skipped"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2HumanMFAInitSkippedResponse> localVarReturnType = new TypeReference<V2HumanMFAInitSkippedResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * @param userId      (required)
   * @param authFactors Specify the Auth Factors you are interested in (optional)
   * @param states      Specify the state of the Auth Factors (optional)
   * @return V2ListAuthenticationFactorsResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListAuthenticationFactorsResponse listAuthenticationFactors(String userId, List<String> authFactors, List<String> states) throws ApiException {
    return this.listAuthenticationFactors(userId, authFactors, states, Collections.emptyMap());
  }


  /**
   * @param userId            (required)
   * @param authFactors       Specify the Auth Factors you are interested in (optional)
   * @param states            Specify the state of the Auth Factors (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ListAuthenticationFactorsResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListAuthenticationFactorsResponse listAuthenticationFactors(String userId, List<String> authFactors, List<String> states, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling listAuthenticationFactors");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/authentication_factors/_search"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "authFactors", authFactors));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "states", states));

    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2ListAuthenticationFactorsResponse> localVarReturnType = new TypeReference<V2ListAuthenticationFactorsResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * List all possible authentication methods of a user
   * List all possible authentication methods of a user like password, passwordless, (T)OTP and more..
   *
   * @param userId                          (required)
   * @param domainQueryIncludeWithoutDomain List also auth method types without domain information like passkey and U2F added through V1 APIs / Login UI. (optional)
   * @param domainQueryDomain               List only auth methods with specific domain. (optional)
   * @return V2ListAuthenticationMethodTypesResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListAuthenticationMethodTypesResponse listAuthenticationMethodTypes(String userId, Boolean domainQueryIncludeWithoutDomain, String domainQueryDomain) throws ApiException {
    return this.listAuthenticationMethodTypes(userId, domainQueryIncludeWithoutDomain, domainQueryDomain, Collections.emptyMap());
  }


  /**
   * List all possible authentication methods of a user
   * List all possible authentication methods of a user like password, passwordless, (T)OTP and more..
   *
   * @param userId                          (required)
   * @param domainQueryIncludeWithoutDomain List also auth method types without domain information like passkey and U2F added through V1 APIs / Login UI. (optional)
   * @param domainQueryDomain               List only auth methods with specific domain. (optional)
   * @param additionalHeaders               additionalHeaders for this call
   * @return V2ListAuthenticationMethodTypesResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListAuthenticationMethodTypesResponse listAuthenticationMethodTypes(String userId, Boolean domainQueryIncludeWithoutDomain, String domainQueryDomain, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling listAuthenticationMethodTypes");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/authentication_methods"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("domainQuery.includeWithoutDomain", domainQueryIncludeWithoutDomain));
    localVarQueryParams.addAll(apiClient.parameterToPair("domainQuery.domain", domainQueryDomain));

    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2ListAuthenticationMethodTypesResponse> localVarReturnType = new TypeReference<V2ListAuthenticationMethodTypesResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "GET",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * List links to an identity provider of an user
   * List links to an identity provider of an user.
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2ListIDPLinksResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListIDPLinksResponse listIDPLinks(String userId, UserServiceListIDPLinksBody body) throws ApiException {
    return this.listIDPLinks(userId, body, Collections.emptyMap());
  }


  /**
   * List links to an identity provider of an user
   * List links to an identity provider of an user.
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ListIDPLinksResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListIDPLinksResponse listIDPLinks(String userId, UserServiceListIDPLinksBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling listIDPLinks");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling listIDPLinks");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/links/_search"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2ListIDPLinksResponse> localVarReturnType = new TypeReference<V2ListIDPLinksResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * List passkeys of an user
   * List passkeys of an user
   *
   * @param userId (required)
   * @return V2ListPasskeysResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListPasskeysResponse listPasskeys(String userId) throws ApiException {
    return this.listPasskeys(userId, Collections.emptyMap());
  }


  /**
   * List passkeys of an user
   * List passkeys of an user
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ListPasskeysResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListPasskeysResponse listPasskeys(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling listPasskeys");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys/_search"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2ListPasskeysResponse> localVarReturnType = new TypeReference<V2ListPasskeysResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Search Users
   * Search for users. By default, we will return all users of your instance that you have permission to read. Make sure to include a limit and sorting for pagination.
   *
   * @param body (required)
   * @return V2ListUsersResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListUsersResponse listUsers(V2ListUsersRequest body) throws ApiException {
    return this.listUsers(body, Collections.emptyMap());
  }


  /**
   * Search Users
   * Search for users. By default, we will return all users of your instance that you have permission to read. Make sure to include a limit and sorting for pagination.
   *
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ListUsersResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListUsersResponse listUsers(V2ListUsersRequest body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling listUsers");
    }

    // create path and map variables
    String localVarPath = "/v2/users";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2ListUsersResponse> localVarReturnType = new TypeReference<V2ListUsersResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Lock user
   * The state of the user will be changed to &#39;locked&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;locked&#39;. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..
   *
   * @param userId (required)
   * @return V2LockUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2LockUserResponse lockUser(String userId) throws ApiException {
    return this.lockUser(userId, Collections.emptyMap());
  }


  /**
   * Lock user
   * The state of the user will be changed to &#39;locked&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;locked&#39;. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2LockUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2LockUserResponse lockUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling lockUser");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/lock"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2LockUserResponse> localVarReturnType = new TypeReference<V2LockUserResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Request a code to reset a password
   * Request a code to reset a password..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2PasswordResetResponse
   * @throws ApiException if fails to make API call
   */
  public V2PasswordResetResponse passwordReset(String userId, UserServicePasswordResetBody body) throws ApiException {
    return this.passwordReset(userId, body, Collections.emptyMap());
  }


  /**
   * Request a code to reset a password
   * Request a code to reset a password..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2PasswordResetResponse
   * @throws ApiException if fails to make API call
   */
  public V2PasswordResetResponse passwordReset(String userId, UserServicePasswordResetBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling passwordReset");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling passwordReset");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/password_reset"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2PasswordResetResponse> localVarReturnType = new TypeReference<V2PasswordResetResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Reactivate user
   * Reactivate a user with the state &#39;deactivated&#39;. The user will be able to log in again afterward. The endpoint returns an error if the user is not in the state &#39;deactivated&#39;..
   *
   * @param userId (required)
   * @return V2ReactivateUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2ReactivateUserResponse reactivateUser(String userId) throws ApiException {
    return this.reactivateUser(userId, Collections.emptyMap());
  }


  /**
   * Reactivate user
   * Reactivate a user with the state &#39;deactivated&#39;. The user will be able to log in again afterward. The endpoint returns an error if the user is not in the state &#39;deactivated&#39;..
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ReactivateUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2ReactivateUserResponse reactivateUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling reactivateUser");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/reactivate"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2ReactivateUserResponse> localVarReturnType = new TypeReference<V2ReactivateUserResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Start the registration of passkey for a user
   * Start the registration of a passkey for a user, as a response the public key credential creation options are returned, which are used to verify the passkey..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2RegisterPasskeyResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterPasskeyResponse registerPasskey(String userId, UserServiceRegisterPasskeyBody body) throws ApiException {
    return this.registerPasskey(userId, body, Collections.emptyMap());
  }


  /**
   * Start the registration of passkey for a user
   * Start the registration of a passkey for a user, as a response the public key credential creation options are returned, which are used to verify the passkey..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RegisterPasskeyResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterPasskeyResponse registerPasskey(String userId, UserServiceRegisterPasskeyBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling registerPasskey");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling registerPasskey");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RegisterPasskeyResponse> localVarReturnType = new TypeReference<V2RegisterPasskeyResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Start the registration of a TOTP generator for a user
   * Start the registration of a TOTP generator for a user, as a response a secret returned, which is used to initialize a TOTP app or device..
   *
   * @param userId (required)
   * @return V2RegisterTOTPResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterTOTPResponse registerTOTP(String userId) throws ApiException {
    return this.registerTOTP(userId, Collections.emptyMap());
  }


  /**
   * Start the registration of a TOTP generator for a user
   * Start the registration of a TOTP generator for a user, as a response a secret returned, which is used to initialize a TOTP app or device..
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RegisterTOTPResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterTOTPResponse registerTOTP(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling registerTOTP");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/totp"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RegisterTOTPResponse> localVarReturnType = new TypeReference<V2RegisterTOTPResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Start the registration of a u2f token for a user
   * Start the registration of a u2f token for a user, as a response the public key credential creation options are returned, which are used to verify the u2f token..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2RegisterU2FResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterU2FResponse registerU2F(String userId, UserServiceRegisterU2FBody body) throws ApiException {
    return this.registerU2F(userId, body, Collections.emptyMap());
  }


  /**
   * Start the registration of a u2f token for a user
   * Start the registration of a u2f token for a user, as a response the public key credential creation options are returned, which are used to verify the u2f token..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RegisterU2FResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterU2FResponse registerU2F(String userId, UserServiceRegisterU2FBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling registerU2F");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling registerU2F");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/u2f"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RegisterU2FResponse> localVarReturnType = new TypeReference<V2RegisterU2FResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Remove link of an identity provider to an user
   * Remove link of an identity provider to an user.
   *
   * @param userId       (required)
   * @param idpId        (required)
   * @param linkedUserId (required)
   * @return V2RemoveIDPLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveIDPLinkResponse removeIDPLink(String userId, String idpId, String linkedUserId) throws ApiException {
    return this.removeIDPLink(userId, idpId, linkedUserId, Collections.emptyMap());
  }


  /**
   * Remove link of an identity provider to an user
   * Remove link of an identity provider to an user.
   *
   * @param userId            (required)
   * @param idpId             (required)
   * @param linkedUserId      (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveIDPLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveIDPLinkResponse removeIDPLink(String userId, String idpId, String linkedUserId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling removeIDPLink");
    }

    // verify the required parameter 'idpId' is set
    if (idpId == null) {
      throw new ApiException(400, "Missing the required parameter 'idpId' when calling removeIDPLink");
    }

    // verify the required parameter 'linkedUserId' is set
    if (linkedUserId == null) {
      throw new ApiException(400, "Missing the required parameter 'linkedUserId' when calling removeIDPLink");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/links/{idpId}/{linkedUserId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "idpId" + "\\}", apiClient.escapeString(apiClient.parameterToString(idpId)))
      .replaceAll("\\{" + "linkedUserId" + "\\}", apiClient.escapeString(apiClient.parameterToString(linkedUserId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RemoveIDPLinkResponse> localVarReturnType = new TypeReference<V2RemoveIDPLinkResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "DELETE",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Remove One-Time Password (OTP) Email from a user
   * Remove the configured One-Time Password (OTP) Email factor of a user. As only one OTP Email per user is allowed, the user will not have OTP Email as a second factor afterward.
   *
   * @param userId (required)
   * @return V2RemoveOTPEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveOTPEmailResponse removeOTPEmail(String userId) throws ApiException {
    return this.removeOTPEmail(userId, Collections.emptyMap());
  }


  /**
   * Remove One-Time Password (OTP) Email from a user
   * Remove the configured One-Time Password (OTP) Email factor of a user. As only one OTP Email per user is allowed, the user will not have OTP Email as a second factor afterward.
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveOTPEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveOTPEmailResponse removeOTPEmail(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling removeOTPEmail");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/otp_email"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RemoveOTPEmailResponse> localVarReturnType = new TypeReference<V2RemoveOTPEmailResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "DELETE",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Remove One-Time Password (OTP) SMS from a user
   * Remove the configured One-Time Password (OTP) SMS factor of a user. As only one OTP SMS per user is allowed, the user will not have OTP SMS as a second factor afterward.
   *
   * @param userId (required)
   * @return V2RemoveOTPSMSResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveOTPSMSResponse removeOTPSMS(String userId) throws ApiException {
    return this.removeOTPSMS(userId, Collections.emptyMap());
  }


  /**
   * Remove One-Time Password (OTP) SMS from a user
   * Remove the configured One-Time Password (OTP) SMS factor of a user. As only one OTP SMS per user is allowed, the user will not have OTP SMS as a second factor afterward.
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveOTPSMSResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveOTPSMSResponse removeOTPSMS(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling removeOTPSMS");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/otp_sms"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RemoveOTPSMSResponse> localVarReturnType = new TypeReference<V2RemoveOTPSMSResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "DELETE",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Remove passkey from a user
   * Remove passkey from a user.
   *
   * @param userId    (required)
   * @param passkeyId (required)
   * @return V2RemovePasskeyResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemovePasskeyResponse removePasskey(String userId, String passkeyId) throws ApiException {
    return this.removePasskey(userId, passkeyId, Collections.emptyMap());
  }


  /**
   * Remove passkey from a user
   * Remove passkey from a user.
   *
   * @param userId            (required)
   * @param passkeyId         (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemovePasskeyResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemovePasskeyResponse removePasskey(String userId, String passkeyId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling removePasskey");
    }

    // verify the required parameter 'passkeyId' is set
    if (passkeyId == null) {
      throw new ApiException(400, "Missing the required parameter 'passkeyId' when calling removePasskey");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys/{passkeyId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "passkeyId" + "\\}", apiClient.escapeString(apiClient.parameterToString(passkeyId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RemovePasskeyResponse> localVarReturnType = new TypeReference<V2RemovePasskeyResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "DELETE",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Delete the user phone
   * Delete the phone number of a user.
   *
   * @param userId (required)
   * @return V2RemovePhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemovePhoneResponse removePhone(String userId) throws ApiException {
    return this.removePhone(userId, Collections.emptyMap());
  }


  /**
   * Delete the user phone
   * Delete the phone number of a user.
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemovePhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemovePhoneResponse removePhone(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling removePhone");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/phone"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RemovePhoneResponse> localVarReturnType = new TypeReference<V2RemovePhoneResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "DELETE",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Remove TOTP generator from a user
   * Remove the configured TOTP generator of a user. As only one TOTP generator per user is allowed, the user will not have TOTP as a second factor afterward.
   *
   * @param userId (required)
   * @return V2RemoveTOTPResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveTOTPResponse removeTOTP(String userId) throws ApiException {
    return this.removeTOTP(userId, Collections.emptyMap());
  }


  /**
   * Remove TOTP generator from a user
   * Remove the configured TOTP generator of a user. As only one TOTP generator per user is allowed, the user will not have TOTP as a second factor afterward.
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveTOTPResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveTOTPResponse removeTOTP(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling removeTOTP");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/totp"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RemoveTOTPResponse> localVarReturnType = new TypeReference<V2RemoveTOTPResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "DELETE",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Remove u2f token from a user
   * Remove u2f token from a user
   *
   * @param userId (required)
   * @param u2fId  (required)
   * @return V2RemoveU2FResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveU2FResponse removeU2F(String userId, String u2fId) throws ApiException {
    return this.removeU2F(userId, u2fId, Collections.emptyMap());
  }


  /**
   * Remove u2f token from a user
   * Remove u2f token from a user
   *
   * @param userId            (required)
   * @param u2fId             (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveU2FResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveU2FResponse removeU2F(String userId, String u2fId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling removeU2F");
    }

    // verify the required parameter 'u2fId' is set
    if (u2fId == null) {
      throw new ApiException(400, "Missing the required parameter 'u2fId' when calling removeU2F");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/u2f/{u2fId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "u2fId" + "\\}", apiClient.escapeString(apiClient.parameterToString(u2fId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RemoveU2FResponse> localVarReturnType = new TypeReference<V2RemoveU2FResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "DELETE",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Resend code to verify user email
   * Resend code to verify user email.
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2ResendEmailCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendEmailCodeResponse resendEmailCode(String userId, UserServiceResendEmailCodeBody body) throws ApiException {
    return this.resendEmailCode(userId, body, Collections.emptyMap());
  }


  /**
   * Resend code to verify user email
   * Resend code to verify user email.
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ResendEmailCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendEmailCodeResponse resendEmailCode(String userId, UserServiceResendEmailCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling resendEmailCode");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling resendEmailCode");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/email/resend"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2ResendEmailCodeResponse> localVarReturnType = new TypeReference<V2ResendEmailCodeResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Resend an invite code for a user
   * Resend an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods. A resend is only possible if a code has been created previously and sent to the user. If there is no code or it was directly returned, an error will be returned.
   *
   * @param userId (required)
   * @return V2ResendInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendInviteCodeResponse resendInviteCode(String userId) throws ApiException {
    return this.resendInviteCode(userId, Collections.emptyMap());
  }


  /**
   * Resend an invite code for a user
   * Resend an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods. A resend is only possible if a code has been created previously and sent to the user. If there is no code or it was directly returned, an error will be returned.
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ResendInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendInviteCodeResponse resendInviteCode(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling resendInviteCode");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/invite_code/resend"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2ResendInviteCodeResponse> localVarReturnType = new TypeReference<V2ResendInviteCodeResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Resend code to verify user phone
   * Resend code to verify user phone.
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2ResendPhoneCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendPhoneCodeResponse resendPhoneCode(String userId, UserServiceResendPhoneCodeBody body) throws ApiException {
    return this.resendPhoneCode(userId, body, Collections.emptyMap());
  }


  /**
   * Resend code to verify user phone
   * Resend code to verify user phone.
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ResendPhoneCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendPhoneCodeResponse resendPhoneCode(String userId, UserServiceResendPhoneCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling resendPhoneCode");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling resendPhoneCode");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/phone/resend"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2ResendPhoneCodeResponse> localVarReturnType = new TypeReference<V2ResendPhoneCodeResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Retrieve the information returned by the identity provider
   * Retrieve the information returned by the identity provider for registration or updating an existing user with new information..
   *
   * @param idpIntentId ID of the idp intent, previously returned on the success response of the IDP callback (required)
   * @param body        (required)
   * @return V2RetrieveIdentityProviderIntentResponse
   * @throws ApiException if fails to make API call
   */
  public V2RetrieveIdentityProviderIntentResponse retrieveIdentityProviderIntent(String idpIntentId, UserServiceRetrieveIdentityProviderIntentBody body) throws ApiException {
    return this.retrieveIdentityProviderIntent(idpIntentId, body, Collections.emptyMap());
  }


  /**
   * Retrieve the information returned by the identity provider
   * Retrieve the information returned by the identity provider for registration or updating an existing user with new information..
   *
   * @param idpIntentId       ID of the idp intent, previously returned on the success response of the IDP callback (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RetrieveIdentityProviderIntentResponse
   * @throws ApiException if fails to make API call
   */
  public V2RetrieveIdentityProviderIntentResponse retrieveIdentityProviderIntent(String idpIntentId, UserServiceRetrieveIdentityProviderIntentBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'idpIntentId' is set
    if (idpIntentId == null) {
      throw new ApiException(400, "Missing the required parameter 'idpIntentId' when calling retrieveIdentityProviderIntent");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling retrieveIdentityProviderIntent");
    }

    // create path and map variables
    String localVarPath = "/v2/idp_intents/{idpIntentId}"
      .replaceAll("\\{" + "idpIntentId" + "\\}", apiClient.escapeString(apiClient.parameterToString(idpIntentId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2RetrieveIdentityProviderIntentResponse> localVarReturnType = new TypeReference<V2RetrieveIdentityProviderIntentResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Send code to verify user email
   * Send code to verify user email.
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2SendEmailCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2SendEmailCodeResponse sendEmailCode(String userId, UserServiceSendEmailCodeBody body) throws ApiException {
    return this.sendEmailCode(userId, body, Collections.emptyMap());
  }


  /**
   * Send code to verify user email
   * Send code to verify user email.
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2SendEmailCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2SendEmailCodeResponse sendEmailCode(String userId, UserServiceSendEmailCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling sendEmailCode");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling sendEmailCode");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/email/send"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2SendEmailCodeResponse> localVarReturnType = new TypeReference<V2SendEmailCodeResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Change the user email
   * Change the email address of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by email..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2SetEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetEmailResponse setEmail(String userId, UserServiceSetEmailBody body) throws ApiException {
    return this.setEmail(userId, body, Collections.emptyMap());
  }


  /**
   * Change the user email
   * Change the email address of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by email..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2SetEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetEmailResponse setEmail(String userId, UserServiceSetEmailBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling setEmail");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling setEmail");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/email"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2SetEmailResponse> localVarReturnType = new TypeReference<V2SetEmailResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Change password
   * Change the password of a user with either a verification code or the current password..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2SetPasswordResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetPasswordResponse setPassword(String userId, V2UserServiceSetPasswordBody body) throws ApiException {
    return this.setPassword(userId, body, Collections.emptyMap());
  }


  /**
   * Change password
   * Change the password of a user with either a verification code or the current password..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2SetPasswordResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetPasswordResponse setPassword(String userId, V2UserServiceSetPasswordBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling setPassword");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling setPassword");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/password"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2SetPasswordResponse> localVarReturnType = new TypeReference<V2SetPasswordResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Set the user phone
   * Set the phone number of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by sms..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2SetPhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetPhoneResponse setPhone(String userId, UserServiceSetPhoneBody body) throws ApiException {
    return this.setPhone(userId, body, Collections.emptyMap());
  }


  /**
   * Set the user phone
   * Set the phone number of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by sms..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2SetPhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetPhoneResponse setPhone(String userId, UserServiceSetPhoneBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling setPhone");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling setPhone");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/phone"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2SetPhoneResponse> localVarReturnType = new TypeReference<V2SetPhoneResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Start flow with an identity provider
   * Start a flow with an identity provider, for external login, registration or linking..
   *
   * @param body (required)
   * @return V2StartIdentityProviderIntentResponse
   * @throws ApiException if fails to make API call
   */
  public V2StartIdentityProviderIntentResponse startIdentityProviderIntent(V2StartIdentityProviderIntentRequest body) throws ApiException {
    return this.startIdentityProviderIntent(body, Collections.emptyMap());
  }


  /**
   * Start flow with an identity provider
   * Start a flow with an identity provider, for external login, registration or linking..
   *
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2StartIdentityProviderIntentResponse
   * @throws ApiException if fails to make API call
   */
  public V2StartIdentityProviderIntentResponse startIdentityProviderIntent(V2StartIdentityProviderIntentRequest body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling startIdentityProviderIntent");
    }

    // create path and map variables
    String localVarPath = "/v2/idp_intents";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2StartIdentityProviderIntentResponse> localVarReturnType = new TypeReference<V2StartIdentityProviderIntentResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Unlock user
   * The state of the user will be changed to &#39;locked&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;locked&#39;. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..
   *
   * @param userId (required)
   * @return V2UnlockUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2UnlockUserResponse unlockUser(String userId) throws ApiException {
    return this.unlockUser(userId, Collections.emptyMap());
  }


  /**
   * Unlock user
   * The state of the user will be changed to &#39;locked&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;locked&#39;. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..
   *
   * @param userId            (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2UnlockUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2UnlockUserResponse unlockUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling unlockUser");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/unlock"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2UnlockUserResponse> localVarReturnType = new TypeReference<V2UnlockUserResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Update User
   * Update all information from a user..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2UpdateHumanUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2UpdateHumanUserResponse updateHumanUser(String userId, UserServiceUpdateHumanUserBody body) throws ApiException {
    return this.updateHumanUser(userId, body, Collections.emptyMap());
  }


  /**
   * Update User
   * Update all information from a user..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2UpdateHumanUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2UpdateHumanUserResponse updateHumanUser(String userId, UserServiceUpdateHumanUserBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling updateHumanUser");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling updateHumanUser");
    }

    // create path and map variables
    String localVarPath = "/v2/users/human/{userId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2UpdateHumanUserResponse> localVarReturnType = new TypeReference<V2UpdateHumanUserResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "PUT",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Verify the email
   * Verify the email with the generated code.
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2VerifyEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyEmailResponse verifyEmail(String userId, UserServiceVerifyEmailBody body) throws ApiException {
    return this.verifyEmail(userId, body, Collections.emptyMap());
  }


  /**
   * Verify the email
   * Verify the email with the generated code.
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyEmailResponse verifyEmail(String userId, UserServiceVerifyEmailBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling verifyEmail");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling verifyEmail");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/email/verify"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2VerifyEmailResponse> localVarReturnType = new TypeReference<V2VerifyEmailResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Verify an invite code for a user
   * Verify the invite code of a user previously issued. This will set their email to a verified state and allow the user to set up their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods.
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2VerifyInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyInviteCodeResponse verifyInviteCode(String userId, UserServiceVerifyInviteCodeBody body) throws ApiException {
    return this.verifyInviteCode(userId, body, Collections.emptyMap());
  }


  /**
   * Verify an invite code for a user
   * Verify the invite code of a user previously issued. This will set their email to a verified state and allow the user to set up their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods.
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyInviteCodeResponse verifyInviteCode(String userId, UserServiceVerifyInviteCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling verifyInviteCode");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling verifyInviteCode");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/invite_code/verify"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2VerifyInviteCodeResponse> localVarReturnType = new TypeReference<V2VerifyInviteCodeResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Verify a passkey for a user
   * Verify the passkey registration with the public key credential..
   *
   * @param userId    (required)
   * @param passkeyId (required)
   * @param body      (required)
   * @return V2VerifyPasskeyRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyPasskeyRegistrationResponse verifyPasskeyRegistration(String userId, String passkeyId, UserServiceVerifyPasskeyRegistrationBody body) throws ApiException {
    return this.verifyPasskeyRegistration(userId, passkeyId, body, Collections.emptyMap());
  }


  /**
   * Verify a passkey for a user
   * Verify the passkey registration with the public key credential..
   *
   * @param userId            (required)
   * @param passkeyId         (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyPasskeyRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyPasskeyRegistrationResponse verifyPasskeyRegistration(String userId, String passkeyId, UserServiceVerifyPasskeyRegistrationBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling verifyPasskeyRegistration");
    }

    // verify the required parameter 'passkeyId' is set
    if (passkeyId == null) {
      throw new ApiException(400, "Missing the required parameter 'passkeyId' when calling verifyPasskeyRegistration");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling verifyPasskeyRegistration");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys/{passkeyId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "passkeyId" + "\\}", apiClient.escapeString(apiClient.parameterToString(passkeyId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2VerifyPasskeyRegistrationResponse> localVarReturnType = new TypeReference<V2VerifyPasskeyRegistrationResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Verify the phone
   * Verify the phone with the generated code..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2VerifyPhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyPhoneResponse verifyPhone(String userId, UserServiceVerifyPhoneBody body) throws ApiException {
    return this.verifyPhone(userId, body, Collections.emptyMap());
  }


  /**
   * Verify the phone
   * Verify the phone with the generated code..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyPhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyPhoneResponse verifyPhone(String userId, UserServiceVerifyPhoneBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling verifyPhone");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling verifyPhone");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/phone/verify"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2VerifyPhoneResponse> localVarReturnType = new TypeReference<V2VerifyPhoneResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Verify a TOTP generator for a user
   * Verify the TOTP registration with a generated code..
   *
   * @param userId (required)
   * @param body   (required)
   * @return V2VerifyTOTPRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyTOTPRegistrationResponse verifyTOTPRegistration(String userId, UserServiceVerifyTOTPRegistrationBody body) throws ApiException {
    return this.verifyTOTPRegistration(userId, body, Collections.emptyMap());
  }


  /**
   * Verify a TOTP generator for a user
   * Verify the TOTP registration with a generated code..
   *
   * @param userId            (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyTOTPRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyTOTPRegistrationResponse verifyTOTPRegistration(String userId, UserServiceVerifyTOTPRegistrationBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling verifyTOTPRegistration");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling verifyTOTPRegistration");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/totp/verify"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2VerifyTOTPRegistrationResponse> localVarReturnType = new TypeReference<V2VerifyTOTPRegistrationResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  /**
   * Verify a u2f token for a user
   * Verify the u2f token registration with the public key credential..
   *
   * @param userId (required)
   * @param u2fId  (required)
   * @param body   (required)
   * @return V2VerifyU2FRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyU2FRegistrationResponse verifyU2FRegistration(String userId, String u2fId, UserServiceVerifyU2FRegistrationBody body) throws ApiException {
    return this.verifyU2FRegistration(userId, u2fId, body, Collections.emptyMap());
  }


  /**
   * Verify a u2f token for a user
   * Verify the u2f token registration with the public key credential..
   *
   * @param userId            (required)
   * @param u2fId             (required)
   * @param body              (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyU2FRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyU2FRegistrationResponse verifyU2FRegistration(String userId, String u2fId, UserServiceVerifyU2FRegistrationBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling verifyU2FRegistration");
    }

    // verify the required parameter 'u2fId' is set
    if (u2fId == null) {
      throw new ApiException(400, "Missing the required parameter 'u2fId' when calling verifyU2FRegistration");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling verifyU2FRegistration");
    }

    // create path and map variables
    String localVarPath = "/v2/users/{userId}/u2f/{u2fId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "u2fId" + "\\}", apiClient.escapeString(apiClient.parameterToString(u2fId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    localVarHeaderParams.putAll(additionalHeaders);


    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    TypeReference<V2VerifyU2FRegistrationResponse> localVarReturnType = new TypeReference<V2VerifyU2FRegistrationResponse>() {
    };
    return apiClient.invokeAPI(
      localVarPath,
      "POST",
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      localVarPostBody,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      localVarReturnType
    );
  }

  @Override
  public <T> T invokeAPI(String url, String method, Object request, TypeReference<T> returnType, Map<String, String> additionalHeaders) throws ApiException {
    String localVarPath = url.replace(apiClient.getBaseURL(), "");
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarHeaderParams.putAll(additionalHeaders);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[]{"zitadelAccessToken"};

    return apiClient.invokeAPI(
      localVarPath,
      method,
      localVarQueryParams,
      localVarCollectionQueryParams,
      localVarQueryStringJoiner.toString(),
      request,
      localVarHeaderParams,
      localVarCookieParams,
      localVarFormParams,
      localVarAccept,
      localVarContentType,
      localVarAuthNames,
      returnType
    );
  }
}

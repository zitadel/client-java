/*
 * merged spec
 * merged spec
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.zitadel.api;

import com.fasterxml.jackson.core.type.TypeReference;

import com.zitadel.ApiException;
import com.zitadel.ApiClient;
import com.zitadel.BaseApi;
import com.zitadel.Configuration;
import com.zitadel.Pair;

import com.zitadel.model.RpcStatus;
import com.zitadel.model.UserServiceAddIDPLinkBody;
import com.zitadel.model.UserServiceCreateInviteCodeBody;
import com.zitadel.model.UserServiceCreatePasskeyRegistrationLinkBody;
import com.zitadel.model.UserServiceListIDPLinksBody;
import com.zitadel.model.UserServicePasswordResetBody;
import com.zitadel.model.UserServiceRegisterPasskeyBody;
import com.zitadel.model.UserServiceRegisterU2FBody;
import com.zitadel.model.UserServiceResendEmailCodeBody;
import com.zitadel.model.UserServiceResendPhoneCodeBody;
import com.zitadel.model.UserServiceRetrieveIdentityProviderIntentBody;
import com.zitadel.model.UserServiceSendEmailCodeBody;
import com.zitadel.model.UserServiceSetEmailBody;
import com.zitadel.model.UserServiceSetPhoneBody;
import com.zitadel.model.UserServiceUpdateHumanUserBody;
import com.zitadel.model.UserServiceVerifyEmailBody;
import com.zitadel.model.UserServiceVerifyInviteCodeBody;
import com.zitadel.model.UserServiceVerifyPasskeyRegistrationBody;
import com.zitadel.model.UserServiceVerifyPhoneBody;
import com.zitadel.model.UserServiceVerifyTOTPRegistrationBody;
import com.zitadel.model.UserServiceVerifyU2FRegistrationBody;
import com.zitadel.model.V2AddHumanUserRequest;
import com.zitadel.model.V2AddHumanUserResponse;
import com.zitadel.model.V2AddIDPLinkResponse;
import com.zitadel.model.V2AddOTPEmailResponse;
import com.zitadel.model.V2AddOTPSMSResponse;
import com.zitadel.model.V2CreateInviteCodeResponse;
import com.zitadel.model.V2CreatePasskeyRegistrationLinkResponse;
import com.zitadel.model.V2DeactivateUserResponse;
import com.zitadel.model.V2DeleteUserResponse;
import com.zitadel.model.V2GetUserByIDResponse;
import com.zitadel.model.V2HumanMFAInitSkippedResponse;
import com.zitadel.model.V2ListAuthenticationFactorsResponse;
import com.zitadel.model.V2ListAuthenticationMethodTypesResponse;
import com.zitadel.model.V2ListIDPLinksResponse;
import com.zitadel.model.V2ListPasskeysResponse;
import com.zitadel.model.V2ListUsersRequest;
import com.zitadel.model.V2ListUsersResponse;
import com.zitadel.model.V2LockUserResponse;
import com.zitadel.model.V2PasswordResetResponse;
import com.zitadel.model.V2ReactivateUserResponse;
import com.zitadel.model.V2RegisterPasskeyResponse;
import com.zitadel.model.V2RegisterTOTPResponse;
import com.zitadel.model.V2RegisterU2FResponse;
import com.zitadel.model.V2RemoveIDPLinkResponse;
import com.zitadel.model.V2RemoveOTPEmailResponse;
import com.zitadel.model.V2RemoveOTPSMSResponse;
import com.zitadel.model.V2RemovePasskeyResponse;
import com.zitadel.model.V2RemovePhoneResponse;
import com.zitadel.model.V2RemoveTOTPResponse;
import com.zitadel.model.V2RemoveU2FResponse;
import com.zitadel.model.V2ResendEmailCodeResponse;
import com.zitadel.model.V2ResendInviteCodeResponse;
import com.zitadel.model.V2ResendPhoneCodeResponse;
import com.zitadel.model.V2RetrieveIdentityProviderIntentResponse;
import com.zitadel.model.V2SendEmailCodeResponse;
import com.zitadel.model.V2SetEmailResponse;
import com.zitadel.model.V2SetPasswordResponse;
import com.zitadel.model.V2SetPhoneResponse;
import com.zitadel.model.V2StartIdentityProviderIntentRequest;
import com.zitadel.model.V2StartIdentityProviderIntentResponse;
import com.zitadel.model.V2UnlockUserResponse;
import com.zitadel.model.V2UpdateHumanUserResponse;
import com.zitadel.model.V2UserServiceSetPasswordBody;
import com.zitadel.model.V2VerifyEmailResponse;
import com.zitadel.model.V2VerifyInviteCodeResponse;
import com.zitadel.model.V2VerifyPasskeyRegistrationResponse;
import com.zitadel.model.V2VerifyPhoneResponse;
import com.zitadel.model.V2VerifyTOTPRegistrationResponse;
import com.zitadel.model.V2VerifyU2FRegistrationResponse;


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.12.0")
public class UserServiceApi extends BaseApi {

  public UserServiceApi() {
    super(Configuration.getDefaultApiClient());
  }

  public UserServiceApi(ApiClient apiClient) {
    super(apiClient);
  }

  /**
   * Create a new human user
   * Create/import a new user with the type human. The newly created user will get a verification email if either the email address is not marked as verified and you did not request the verification to be returned.
   * @param body  (required)
   * @return V2AddHumanUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddHumanUserResponse userServiceAddHumanUser(V2AddHumanUserRequest body) throws ApiException {
    return this.userServiceAddHumanUser(body, Collections.emptyMap());
  }


  /**
   * Create a new human user
   * Create/import a new user with the type human. The newly created user will get a verification email if either the email address is not marked as verified and you did not request the verification to be returned.
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2AddHumanUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddHumanUserResponse userServiceAddHumanUser(V2AddHumanUserRequest body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceAddHumanUser");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/human";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2AddHumanUserResponse> localVarReturnType = new TypeReference<V2AddHumanUserResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Add link to an identity provider to an user
   * Add link to an identity provider to an user..
   * @param userId  (required)
   * @param body  (required)
   * @return V2AddIDPLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddIDPLinkResponse userServiceAddIDPLink(String userId, UserServiceAddIDPLinkBody body) throws ApiException {
    return this.userServiceAddIDPLink(userId, body, Collections.emptyMap());
  }


  /**
   * Add link to an identity provider to an user
   * Add link to an identity provider to an user..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2AddIDPLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddIDPLinkResponse userServiceAddIDPLink(String userId, UserServiceAddIDPLinkBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceAddIDPLink");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceAddIDPLink");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/links"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2AddIDPLinkResponse> localVarReturnType = new TypeReference<V2AddIDPLinkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Add OTP Email for a user
   * Add a new One-Time Password (OTP) Email factor to the authenticated user. OTP Email will enable the user to verify a OTP with the latest verified email. The email has to be verified to add the second factor..
   * @param userId  (required)
   * @return V2AddOTPEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddOTPEmailResponse userServiceAddOTPEmail(String userId) throws ApiException {
    return this.userServiceAddOTPEmail(userId, Collections.emptyMap());
  }


  /**
   * Add OTP Email for a user
   * Add a new One-Time Password (OTP) Email factor to the authenticated user. OTP Email will enable the user to verify a OTP with the latest verified email. The email has to be verified to add the second factor..
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2AddOTPEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddOTPEmailResponse userServiceAddOTPEmail(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceAddOTPEmail");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/otp_email"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2AddOTPEmailResponse> localVarReturnType = new TypeReference<V2AddOTPEmailResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Add OTP SMS for a user
   * Add a new One-Time Password (OTP) SMS factor to the authenticated user. OTP SMS will enable the user to verify a OTP with the latest verified phone number. The phone number has to be verified to add the second factor..
   * @param userId  (required)
   * @return V2AddOTPSMSResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddOTPSMSResponse userServiceAddOTPSMS(String userId) throws ApiException {
    return this.userServiceAddOTPSMS(userId, Collections.emptyMap());
  }


  /**
   * Add OTP SMS for a user
   * Add a new One-Time Password (OTP) SMS factor to the authenticated user. OTP SMS will enable the user to verify a OTP with the latest verified phone number. The phone number has to be verified to add the second factor..
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2AddOTPSMSResponse
   * @throws ApiException if fails to make API call
   */
  public V2AddOTPSMSResponse userServiceAddOTPSMS(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceAddOTPSMS");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/otp_sms"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2AddOTPSMSResponse> localVarReturnType = new TypeReference<V2AddOTPSMSResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create an invite code for a user
   * Create an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods.
   * @param userId  (required)
   * @param body  (required)
   * @return V2CreateInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2CreateInviteCodeResponse userServiceCreateInviteCode(String userId, UserServiceCreateInviteCodeBody body) throws ApiException {
    return this.userServiceCreateInviteCode(userId, body, Collections.emptyMap());
  }


  /**
   * Create an invite code for a user
   * Create an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods.
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2CreateInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2CreateInviteCodeResponse userServiceCreateInviteCode(String userId, UserServiceCreateInviteCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceCreateInviteCode");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceCreateInviteCode");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/invite_code"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2CreateInviteCodeResponse> localVarReturnType = new TypeReference<V2CreateInviteCodeResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a passkey registration link for a user
   * Create a passkey registration link which includes a code and either return it or send it to the user..
   * @param userId  (required)
   * @param body  (required)
   * @return V2CreatePasskeyRegistrationLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2CreatePasskeyRegistrationLinkResponse userServiceCreatePasskeyRegistrationLink(String userId, UserServiceCreatePasskeyRegistrationLinkBody body) throws ApiException {
    return this.userServiceCreatePasskeyRegistrationLink(userId, body, Collections.emptyMap());
  }


  /**
   * Create a passkey registration link for a user
   * Create a passkey registration link which includes a code and either return it or send it to the user..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2CreatePasskeyRegistrationLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2CreatePasskeyRegistrationLinkResponse userServiceCreatePasskeyRegistrationLink(String userId, UserServiceCreatePasskeyRegistrationLinkBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceCreatePasskeyRegistrationLink");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceCreatePasskeyRegistrationLink");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys/registration_link"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2CreatePasskeyRegistrationLinkResponse> localVarReturnType = new TypeReference<V2CreatePasskeyRegistrationLinkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Deactivate user
   * The state of the user will be changed to &#39;deactivated&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;deactivated&#39;. Use deactivate user when the user should not be able to use the account anymore, but you still need access to the user data..
   * @param userId  (required)
   * @return V2DeactivateUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2DeactivateUserResponse userServiceDeactivateUser(String userId) throws ApiException {
    return this.userServiceDeactivateUser(userId, Collections.emptyMap());
  }


  /**
   * Deactivate user
   * The state of the user will be changed to &#39;deactivated&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;deactivated&#39;. Use deactivate user when the user should not be able to use the account anymore, but you still need access to the user data..
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2DeactivateUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2DeactivateUserResponse userServiceDeactivateUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceDeactivateUser");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/deactivate"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2DeactivateUserResponse> localVarReturnType = new TypeReference<V2DeactivateUserResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete user
   * The state of the user will be changed to &#39;deleted&#39;. The user will not be able to log in anymore. Endpoints requesting this user will return an error &#39;User not found..
   * @param userId  (required)
   * @return V2DeleteUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2DeleteUserResponse userServiceDeleteUser(String userId) throws ApiException {
    return this.userServiceDeleteUser(userId, Collections.emptyMap());
  }


  /**
   * Delete user
   * The state of the user will be changed to &#39;deleted&#39;. The user will not be able to log in anymore. Endpoints requesting this user will return an error &#39;User not found..
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2DeleteUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2DeleteUserResponse userServiceDeleteUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceDeleteUser");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2DeleteUserResponse> localVarReturnType = new TypeReference<V2DeleteUserResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * User by ID
   * Returns the full user object (human or machine) including the profile, email, etc..
   * @param userId User ID of the user you like to get. (required)
   * @return V2GetUserByIDResponse
   * @throws ApiException if fails to make API call
   */
  public V2GetUserByIDResponse userServiceGetUserByID(String userId) throws ApiException {
    return this.userServiceGetUserByID(userId, Collections.emptyMap());
  }


  /**
   * User by ID
   * Returns the full user object (human or machine) including the profile, email, etc..
   * @param userId User ID of the user you like to get. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2GetUserByIDResponse
   * @throws ApiException if fails to make API call
   */
  public V2GetUserByIDResponse userServiceGetUserByID(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceGetUserByID");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2GetUserByIDResponse> localVarReturnType = new TypeReference<V2GetUserByIDResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * MFA Init Skipped
   * Update the last time the user has skipped MFA initialization. The server timestamp is used.
   * @param userId  (required)
   * @return V2HumanMFAInitSkippedResponse
   * @throws ApiException if fails to make API call
   */
  public V2HumanMFAInitSkippedResponse userServiceHumanMFAInitSkipped(String userId) throws ApiException {
    return this.userServiceHumanMFAInitSkipped(userId, Collections.emptyMap());
  }


  /**
   * MFA Init Skipped
   * Update the last time the user has skipped MFA initialization. The server timestamp is used.
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2HumanMFAInitSkippedResponse
   * @throws ApiException if fails to make API call
   */
  public V2HumanMFAInitSkippedResponse userServiceHumanMFAInitSkipped(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceHumanMFAInitSkipped");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/mfa_init_skipped"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2HumanMFAInitSkippedResponse> localVarReturnType = new TypeReference<V2HumanMFAInitSkippedResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * 
   * 
   * @param userId  (required)
   * @param authFactors Specify the Auth Factors you are interested in (optional)
   * @param states Specify the state of the Auth Factors (optional)
   * @return V2ListAuthenticationFactorsResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListAuthenticationFactorsResponse userServiceListAuthenticationFactors(String userId, List<String> authFactors, List<String> states) throws ApiException {
    return this.userServiceListAuthenticationFactors(userId, authFactors, states, Collections.emptyMap());
  }


  /**
   * 
   * 
   * @param userId  (required)
   * @param authFactors Specify the Auth Factors you are interested in (optional)
   * @param states Specify the state of the Auth Factors (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ListAuthenticationFactorsResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListAuthenticationFactorsResponse userServiceListAuthenticationFactors(String userId, List<String> authFactors, List<String> states, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceListAuthenticationFactors");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/authentication_factors/_search"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "authFactors", authFactors));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "states", states));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2ListAuthenticationFactorsResponse> localVarReturnType = new TypeReference<V2ListAuthenticationFactorsResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List all possible authentication methods of a user
   * List all possible authentication methods of a user like password, passwordless, (T)OTP and more..
   * @param userId  (required)
   * @param domainQueryIncludeWithoutDomain List also auth method types without domain information like passkey and U2F added through V1 APIs / Login UI. (optional)
   * @param domainQueryDomain List only auth methods with specific domain. (optional)
   * @return V2ListAuthenticationMethodTypesResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListAuthenticationMethodTypesResponse userServiceListAuthenticationMethodTypes(String userId, Boolean domainQueryIncludeWithoutDomain, String domainQueryDomain) throws ApiException {
    return this.userServiceListAuthenticationMethodTypes(userId, domainQueryIncludeWithoutDomain, domainQueryDomain, Collections.emptyMap());
  }


  /**
   * List all possible authentication methods of a user
   * List all possible authentication methods of a user like password, passwordless, (T)OTP and more..
   * @param userId  (required)
   * @param domainQueryIncludeWithoutDomain List also auth method types without domain information like passkey and U2F added through V1 APIs / Login UI. (optional)
   * @param domainQueryDomain List only auth methods with specific domain. (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ListAuthenticationMethodTypesResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListAuthenticationMethodTypesResponse userServiceListAuthenticationMethodTypes(String userId, Boolean domainQueryIncludeWithoutDomain, String domainQueryDomain, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceListAuthenticationMethodTypes");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/authentication_methods"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("domainQuery.includeWithoutDomain", domainQueryIncludeWithoutDomain));
    localVarQueryParams.addAll(apiClient.parameterToPair("domainQuery.domain", domainQueryDomain));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2ListAuthenticationMethodTypesResponse> localVarReturnType = new TypeReference<V2ListAuthenticationMethodTypesResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List links to an identity provider of an user
   * List links to an identity provider of an user.
   * @param userId  (required)
   * @param body  (required)
   * @return V2ListIDPLinksResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListIDPLinksResponse userServiceListIDPLinks(String userId, UserServiceListIDPLinksBody body) throws ApiException {
    return this.userServiceListIDPLinks(userId, body, Collections.emptyMap());
  }


  /**
   * List links to an identity provider of an user
   * List links to an identity provider of an user.
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ListIDPLinksResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListIDPLinksResponse userServiceListIDPLinks(String userId, UserServiceListIDPLinksBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceListIDPLinks");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceListIDPLinks");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/links/_search"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2ListIDPLinksResponse> localVarReturnType = new TypeReference<V2ListIDPLinksResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List passkeys of an user
   * List passkeys of an user
   * @param userId  (required)
   * @return V2ListPasskeysResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListPasskeysResponse userServiceListPasskeys(String userId) throws ApiException {
    return this.userServiceListPasskeys(userId, Collections.emptyMap());
  }


  /**
   * List passkeys of an user
   * List passkeys of an user
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ListPasskeysResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListPasskeysResponse userServiceListPasskeys(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceListPasskeys");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys/_search"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2ListPasskeysResponse> localVarReturnType = new TypeReference<V2ListPasskeysResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search Users
   * Search for users. By default, we will return all users of your instance that you have permission to read. Make sure to include a limit and sorting for pagination.
   * @param body  (required)
   * @return V2ListUsersResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListUsersResponse userServiceListUsers(V2ListUsersRequest body) throws ApiException {
    return this.userServiceListUsers(body, Collections.emptyMap());
  }


  /**
   * Search Users
   * Search for users. By default, we will return all users of your instance that you have permission to read. Make sure to include a limit and sorting for pagination.
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ListUsersResponse
   * @throws ApiException if fails to make API call
   */
  public V2ListUsersResponse userServiceListUsers(V2ListUsersRequest body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceListUsers");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2ListUsersResponse> localVarReturnType = new TypeReference<V2ListUsersResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Lock user
   * The state of the user will be changed to &#39;locked&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;locked&#39;. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..
   * @param userId  (required)
   * @return V2LockUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2LockUserResponse userServiceLockUser(String userId) throws ApiException {
    return this.userServiceLockUser(userId, Collections.emptyMap());
  }


  /**
   * Lock user
   * The state of the user will be changed to &#39;locked&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;locked&#39;. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2LockUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2LockUserResponse userServiceLockUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceLockUser");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/lock"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2LockUserResponse> localVarReturnType = new TypeReference<V2LockUserResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Request a code to reset a password
   * Request a code to reset a password..
   * @param userId  (required)
   * @param body  (required)
   * @return V2PasswordResetResponse
   * @throws ApiException if fails to make API call
   */
  public V2PasswordResetResponse userServicePasswordReset(String userId, UserServicePasswordResetBody body) throws ApiException {
    return this.userServicePasswordReset(userId, body, Collections.emptyMap());
  }


  /**
   * Request a code to reset a password
   * Request a code to reset a password..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2PasswordResetResponse
   * @throws ApiException if fails to make API call
   */
  public V2PasswordResetResponse userServicePasswordReset(String userId, UserServicePasswordResetBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServicePasswordReset");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServicePasswordReset");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/password_reset"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2PasswordResetResponse> localVarReturnType = new TypeReference<V2PasswordResetResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Reactivate user
   * Reactivate a user with the state &#39;deactivated&#39;. The user will be able to log in again afterward. The endpoint returns an error if the user is not in the state &#39;deactivated&#39;..
   * @param userId  (required)
   * @return V2ReactivateUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2ReactivateUserResponse userServiceReactivateUser(String userId) throws ApiException {
    return this.userServiceReactivateUser(userId, Collections.emptyMap());
  }


  /**
   * Reactivate user
   * Reactivate a user with the state &#39;deactivated&#39;. The user will be able to log in again afterward. The endpoint returns an error if the user is not in the state &#39;deactivated&#39;..
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ReactivateUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2ReactivateUserResponse userServiceReactivateUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceReactivateUser");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/reactivate"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2ReactivateUserResponse> localVarReturnType = new TypeReference<V2ReactivateUserResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Start the registration of passkey for a user
   * Start the registration of a passkey for a user, as a response the public key credential creation options are returned, which are used to verify the passkey..
   * @param userId  (required)
   * @param body  (required)
   * @return V2RegisterPasskeyResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterPasskeyResponse userServiceRegisterPasskey(String userId, UserServiceRegisterPasskeyBody body) throws ApiException {
    return this.userServiceRegisterPasskey(userId, body, Collections.emptyMap());
  }


  /**
   * Start the registration of passkey for a user
   * Start the registration of a passkey for a user, as a response the public key credential creation options are returned, which are used to verify the passkey..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RegisterPasskeyResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterPasskeyResponse userServiceRegisterPasskey(String userId, UserServiceRegisterPasskeyBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRegisterPasskey");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceRegisterPasskey");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RegisterPasskeyResponse> localVarReturnType = new TypeReference<V2RegisterPasskeyResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Start the registration of a TOTP generator for a user
   * Start the registration of a TOTP generator for a user, as a response a secret returned, which is used to initialize a TOTP app or device..
   * @param userId  (required)
   * @return V2RegisterTOTPResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterTOTPResponse userServiceRegisterTOTP(String userId) throws ApiException {
    return this.userServiceRegisterTOTP(userId, Collections.emptyMap());
  }


  /**
   * Start the registration of a TOTP generator for a user
   * Start the registration of a TOTP generator for a user, as a response a secret returned, which is used to initialize a TOTP app or device..
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RegisterTOTPResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterTOTPResponse userServiceRegisterTOTP(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRegisterTOTP");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/totp"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RegisterTOTPResponse> localVarReturnType = new TypeReference<V2RegisterTOTPResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Start the registration of a u2f token for a user
   * Start the registration of a u2f token for a user, as a response the public key credential creation options are returned, which are used to verify the u2f token..
   * @param userId  (required)
   * @param body  (required)
   * @return V2RegisterU2FResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterU2FResponse userServiceRegisterU2F(String userId, UserServiceRegisterU2FBody body) throws ApiException {
    return this.userServiceRegisterU2F(userId, body, Collections.emptyMap());
  }


  /**
   * Start the registration of a u2f token for a user
   * Start the registration of a u2f token for a user, as a response the public key credential creation options are returned, which are used to verify the u2f token..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RegisterU2FResponse
   * @throws ApiException if fails to make API call
   */
  public V2RegisterU2FResponse userServiceRegisterU2F(String userId, UserServiceRegisterU2FBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRegisterU2F");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceRegisterU2F");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/u2f"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RegisterU2FResponse> localVarReturnType = new TypeReference<V2RegisterU2FResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Remove link of an identity provider to an user
   * Remove link of an identity provider to an user.
   * @param userId  (required)
   * @param idpId  (required)
   * @param linkedUserId  (required)
   * @return V2RemoveIDPLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveIDPLinkResponse userServiceRemoveIDPLink(String userId, String idpId, String linkedUserId) throws ApiException {
    return this.userServiceRemoveIDPLink(userId, idpId, linkedUserId, Collections.emptyMap());
  }


  /**
   * Remove link of an identity provider to an user
   * Remove link of an identity provider to an user.
   * @param userId  (required)
   * @param idpId  (required)
   * @param linkedUserId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveIDPLinkResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveIDPLinkResponse userServiceRemoveIDPLink(String userId, String idpId, String linkedUserId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRemoveIDPLink");
    }
    
    // verify the required parameter 'idpId' is set
    if (idpId == null) {
      throw new ApiException(400, "Missing the required parameter 'idpId' when calling userServiceRemoveIDPLink");
    }
    
    // verify the required parameter 'linkedUserId' is set
    if (linkedUserId == null) {
      throw new ApiException(400, "Missing the required parameter 'linkedUserId' when calling userServiceRemoveIDPLink");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/links/{idpId}/{linkedUserId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "idpId" + "\\}", apiClient.escapeString(apiClient.parameterToString(idpId)))
      .replaceAll("\\{" + "linkedUserId" + "\\}", apiClient.escapeString(apiClient.parameterToString(linkedUserId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RemoveIDPLinkResponse> localVarReturnType = new TypeReference<V2RemoveIDPLinkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Remove One-Time Password (OTP) Email from a user
   * Remove the configured One-Time Password (OTP) Email factor of a user. As only one OTP Email per user is allowed, the user will not have OTP Email as a second factor afterward.
   * @param userId  (required)
   * @return V2RemoveOTPEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveOTPEmailResponse userServiceRemoveOTPEmail(String userId) throws ApiException {
    return this.userServiceRemoveOTPEmail(userId, Collections.emptyMap());
  }


  /**
   * Remove One-Time Password (OTP) Email from a user
   * Remove the configured One-Time Password (OTP) Email factor of a user. As only one OTP Email per user is allowed, the user will not have OTP Email as a second factor afterward.
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveOTPEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveOTPEmailResponse userServiceRemoveOTPEmail(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRemoveOTPEmail");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/otp_email"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RemoveOTPEmailResponse> localVarReturnType = new TypeReference<V2RemoveOTPEmailResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Remove One-Time Password (OTP) SMS from a user
   * Remove the configured One-Time Password (OTP) SMS factor of a user. As only one OTP SMS per user is allowed, the user will not have OTP SMS as a second factor afterward.
   * @param userId  (required)
   * @return V2RemoveOTPSMSResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveOTPSMSResponse userServiceRemoveOTPSMS(String userId) throws ApiException {
    return this.userServiceRemoveOTPSMS(userId, Collections.emptyMap());
  }


  /**
   * Remove One-Time Password (OTP) SMS from a user
   * Remove the configured One-Time Password (OTP) SMS factor of a user. As only one OTP SMS per user is allowed, the user will not have OTP SMS as a second factor afterward.
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveOTPSMSResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveOTPSMSResponse userServiceRemoveOTPSMS(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRemoveOTPSMS");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/otp_sms"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RemoveOTPSMSResponse> localVarReturnType = new TypeReference<V2RemoveOTPSMSResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Remove passkey from a user
   * Remove passkey from a user.
   * @param userId  (required)
   * @param passkeyId  (required)
   * @return V2RemovePasskeyResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemovePasskeyResponse userServiceRemovePasskey(String userId, String passkeyId) throws ApiException {
    return this.userServiceRemovePasskey(userId, passkeyId, Collections.emptyMap());
  }


  /**
   * Remove passkey from a user
   * Remove passkey from a user.
   * @param userId  (required)
   * @param passkeyId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemovePasskeyResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemovePasskeyResponse userServiceRemovePasskey(String userId, String passkeyId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRemovePasskey");
    }
    
    // verify the required parameter 'passkeyId' is set
    if (passkeyId == null) {
      throw new ApiException(400, "Missing the required parameter 'passkeyId' when calling userServiceRemovePasskey");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys/{passkeyId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "passkeyId" + "\\}", apiClient.escapeString(apiClient.parameterToString(passkeyId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RemovePasskeyResponse> localVarReturnType = new TypeReference<V2RemovePasskeyResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete the user phone
   * Delete the phone number of a user.
   * @param userId  (required)
   * @return V2RemovePhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemovePhoneResponse userServiceRemovePhone(String userId) throws ApiException {
    return this.userServiceRemovePhone(userId, Collections.emptyMap());
  }


  /**
   * Delete the user phone
   * Delete the phone number of a user.
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemovePhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemovePhoneResponse userServiceRemovePhone(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRemovePhone");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/phone"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RemovePhoneResponse> localVarReturnType = new TypeReference<V2RemovePhoneResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Remove TOTP generator from a user
   * Remove the configured TOTP generator of a user. As only one TOTP generator per user is allowed, the user will not have TOTP as a second factor afterward.
   * @param userId  (required)
   * @return V2RemoveTOTPResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveTOTPResponse userServiceRemoveTOTP(String userId) throws ApiException {
    return this.userServiceRemoveTOTP(userId, Collections.emptyMap());
  }


  /**
   * Remove TOTP generator from a user
   * Remove the configured TOTP generator of a user. As only one TOTP generator per user is allowed, the user will not have TOTP as a second factor afterward.
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveTOTPResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveTOTPResponse userServiceRemoveTOTP(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRemoveTOTP");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/totp"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RemoveTOTPResponse> localVarReturnType = new TypeReference<V2RemoveTOTPResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Remove u2f token from a user
   * Remove u2f token from a user
   * @param userId  (required)
   * @param u2fId  (required)
   * @return V2RemoveU2FResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveU2FResponse userServiceRemoveU2F(String userId, String u2fId) throws ApiException {
    return this.userServiceRemoveU2F(userId, u2fId, Collections.emptyMap());
  }


  /**
   * Remove u2f token from a user
   * Remove u2f token from a user
   * @param userId  (required)
   * @param u2fId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RemoveU2FResponse
   * @throws ApiException if fails to make API call
   */
  public V2RemoveU2FResponse userServiceRemoveU2F(String userId, String u2fId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceRemoveU2F");
    }
    
    // verify the required parameter 'u2fId' is set
    if (u2fId == null) {
      throw new ApiException(400, "Missing the required parameter 'u2fId' when calling userServiceRemoveU2F");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/u2f/{u2fId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "u2fId" + "\\}", apiClient.escapeString(apiClient.parameterToString(u2fId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RemoveU2FResponse> localVarReturnType = new TypeReference<V2RemoveU2FResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Resend code to verify user email
   * Resend code to verify user email.
   * @param userId  (required)
   * @param body  (required)
   * @return V2ResendEmailCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendEmailCodeResponse userServiceResendEmailCode(String userId, UserServiceResendEmailCodeBody body) throws ApiException {
    return this.userServiceResendEmailCode(userId, body, Collections.emptyMap());
  }


  /**
   * Resend code to verify user email
   * Resend code to verify user email.
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ResendEmailCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendEmailCodeResponse userServiceResendEmailCode(String userId, UserServiceResendEmailCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceResendEmailCode");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceResendEmailCode");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/email/resend"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2ResendEmailCodeResponse> localVarReturnType = new TypeReference<V2ResendEmailCodeResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Resend an invite code for a user
   * Resend an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods. A resend is only possible if a code has been created previously and sent to the user. If there is no code or it was directly returned, an error will be returned.
   * @param userId  (required)
   * @return V2ResendInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendInviteCodeResponse userServiceResendInviteCode(String userId) throws ApiException {
    return this.userServiceResendInviteCode(userId, Collections.emptyMap());
  }


  /**
   * Resend an invite code for a user
   * Resend an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods. A resend is only possible if a code has been created previously and sent to the user. If there is no code or it was directly returned, an error will be returned.
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ResendInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendInviteCodeResponse userServiceResendInviteCode(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceResendInviteCode");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/invite_code/resend"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2ResendInviteCodeResponse> localVarReturnType = new TypeReference<V2ResendInviteCodeResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Resend code to verify user phone
   * Resend code to verify user phone.
   * @param userId  (required)
   * @param body  (required)
   * @return V2ResendPhoneCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendPhoneCodeResponse userServiceResendPhoneCode(String userId, UserServiceResendPhoneCodeBody body) throws ApiException {
    return this.userServiceResendPhoneCode(userId, body, Collections.emptyMap());
  }


  /**
   * Resend code to verify user phone
   * Resend code to verify user phone.
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2ResendPhoneCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2ResendPhoneCodeResponse userServiceResendPhoneCode(String userId, UserServiceResendPhoneCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceResendPhoneCode");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceResendPhoneCode");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/phone/resend"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2ResendPhoneCodeResponse> localVarReturnType = new TypeReference<V2ResendPhoneCodeResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieve the information returned by the identity provider
   * Retrieve the information returned by the identity provider for registration or updating an existing user with new information..
   * @param idpIntentId ID of the idp intent, previously returned on the success response of the IDP callback (required)
   * @param body  (required)
   * @return V2RetrieveIdentityProviderIntentResponse
   * @throws ApiException if fails to make API call
   */
  public V2RetrieveIdentityProviderIntentResponse userServiceRetrieveIdentityProviderIntent(String idpIntentId, UserServiceRetrieveIdentityProviderIntentBody body) throws ApiException {
    return this.userServiceRetrieveIdentityProviderIntent(idpIntentId, body, Collections.emptyMap());
  }


  /**
   * Retrieve the information returned by the identity provider
   * Retrieve the information returned by the identity provider for registration or updating an existing user with new information..
   * @param idpIntentId ID of the idp intent, previously returned on the success response of the IDP callback (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2RetrieveIdentityProviderIntentResponse
   * @throws ApiException if fails to make API call
   */
  public V2RetrieveIdentityProviderIntentResponse userServiceRetrieveIdentityProviderIntent(String idpIntentId, UserServiceRetrieveIdentityProviderIntentBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'idpIntentId' is set
    if (idpIntentId == null) {
      throw new ApiException(400, "Missing the required parameter 'idpIntentId' when calling userServiceRetrieveIdentityProviderIntent");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceRetrieveIdentityProviderIntent");
    }
    
    // create path and map variables
    String localVarPath = "/v2/idp_intents/{idpIntentId}"
      .replaceAll("\\{" + "idpIntentId" + "\\}", apiClient.escapeString(apiClient.parameterToString(idpIntentId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2RetrieveIdentityProviderIntentResponse> localVarReturnType = new TypeReference<V2RetrieveIdentityProviderIntentResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Send code to verify user email
   * Send code to verify user email.
   * @param userId  (required)
   * @param body  (required)
   * @return V2SendEmailCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2SendEmailCodeResponse userServiceSendEmailCode(String userId, UserServiceSendEmailCodeBody body) throws ApiException {
    return this.userServiceSendEmailCode(userId, body, Collections.emptyMap());
  }


  /**
   * Send code to verify user email
   * Send code to verify user email.
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2SendEmailCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2SendEmailCodeResponse userServiceSendEmailCode(String userId, UserServiceSendEmailCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceSendEmailCode");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceSendEmailCode");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/email/send"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2SendEmailCodeResponse> localVarReturnType = new TypeReference<V2SendEmailCodeResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Change the user email
   * Change the email address of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by email..
   * @param userId  (required)
   * @param body  (required)
   * @return V2SetEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetEmailResponse userServiceSetEmail(String userId, UserServiceSetEmailBody body) throws ApiException {
    return this.userServiceSetEmail(userId, body, Collections.emptyMap());
  }


  /**
   * Change the user email
   * Change the email address of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by email..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2SetEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetEmailResponse userServiceSetEmail(String userId, UserServiceSetEmailBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceSetEmail");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceSetEmail");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/email"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2SetEmailResponse> localVarReturnType = new TypeReference<V2SetEmailResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Change password
   * Change the password of a user with either a verification code or the current password..
   * @param userId  (required)
   * @param body  (required)
   * @return V2SetPasswordResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetPasswordResponse userServiceSetPassword(String userId, V2UserServiceSetPasswordBody body) throws ApiException {
    return this.userServiceSetPassword(userId, body, Collections.emptyMap());
  }


  /**
   * Change password
   * Change the password of a user with either a verification code or the current password..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2SetPasswordResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetPasswordResponse userServiceSetPassword(String userId, V2UserServiceSetPasswordBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceSetPassword");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceSetPassword");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/password"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2SetPasswordResponse> localVarReturnType = new TypeReference<V2SetPasswordResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Set the user phone
   * Set the phone number of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by sms..
   * @param userId  (required)
   * @param body  (required)
   * @return V2SetPhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetPhoneResponse userServiceSetPhone(String userId, UserServiceSetPhoneBody body) throws ApiException {
    return this.userServiceSetPhone(userId, body, Collections.emptyMap());
  }


  /**
   * Set the user phone
   * Set the phone number of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by sms..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2SetPhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2SetPhoneResponse userServiceSetPhone(String userId, UserServiceSetPhoneBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceSetPhone");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceSetPhone");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/phone"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2SetPhoneResponse> localVarReturnType = new TypeReference<V2SetPhoneResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Start flow with an identity provider
   * Start a flow with an identity provider, for external login, registration or linking..
   * @param body  (required)
   * @return V2StartIdentityProviderIntentResponse
   * @throws ApiException if fails to make API call
   */
  public V2StartIdentityProviderIntentResponse userServiceStartIdentityProviderIntent(V2StartIdentityProviderIntentRequest body) throws ApiException {
    return this.userServiceStartIdentityProviderIntent(body, Collections.emptyMap());
  }


  /**
   * Start flow with an identity provider
   * Start a flow with an identity provider, for external login, registration or linking..
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2StartIdentityProviderIntentResponse
   * @throws ApiException if fails to make API call
   */
  public V2StartIdentityProviderIntentResponse userServiceStartIdentityProviderIntent(V2StartIdentityProviderIntentRequest body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceStartIdentityProviderIntent");
    }
    
    // create path and map variables
    String localVarPath = "/v2/idp_intents";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2StartIdentityProviderIntentResponse> localVarReturnType = new TypeReference<V2StartIdentityProviderIntentResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Unlock user
   * The state of the user will be changed to &#39;locked&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;locked&#39;. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..
   * @param userId  (required)
   * @return V2UnlockUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2UnlockUserResponse userServiceUnlockUser(String userId) throws ApiException {
    return this.userServiceUnlockUser(userId, Collections.emptyMap());
  }


  /**
   * Unlock user
   * The state of the user will be changed to &#39;locked&#39;. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state &#39;locked&#39;. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..
   * @param userId  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2UnlockUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2UnlockUserResponse userServiceUnlockUser(String userId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceUnlockUser");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/unlock"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2UnlockUserResponse> localVarReturnType = new TypeReference<V2UnlockUserResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update User
   * Update all information from a user..
   * @param userId  (required)
   * @param body  (required)
   * @return V2UpdateHumanUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2UpdateHumanUserResponse userServiceUpdateHumanUser(String userId, UserServiceUpdateHumanUserBody body) throws ApiException {
    return this.userServiceUpdateHumanUser(userId, body, Collections.emptyMap());
  }


  /**
   * Update User
   * Update all information from a user..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2UpdateHumanUserResponse
   * @throws ApiException if fails to make API call
   */
  public V2UpdateHumanUserResponse userServiceUpdateHumanUser(String userId, UserServiceUpdateHumanUserBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceUpdateHumanUser");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceUpdateHumanUser");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/human/{userId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2UpdateHumanUserResponse> localVarReturnType = new TypeReference<V2UpdateHumanUserResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Verify the email
   * Verify the email with the generated code.
   * @param userId  (required)
   * @param body  (required)
   * @return V2VerifyEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyEmailResponse userServiceVerifyEmail(String userId, UserServiceVerifyEmailBody body) throws ApiException {
    return this.userServiceVerifyEmail(userId, body, Collections.emptyMap());
  }


  /**
   * Verify the email
   * Verify the email with the generated code.
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyEmailResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyEmailResponse userServiceVerifyEmail(String userId, UserServiceVerifyEmailBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceVerifyEmail");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceVerifyEmail");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/email/verify"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2VerifyEmailResponse> localVarReturnType = new TypeReference<V2VerifyEmailResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Verify an invite code for a user
   * Verify the invite code of a user previously issued. This will set their email to a verified state and allow the user to set up their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods.
   * @param userId  (required)
   * @param body  (required)
   * @return V2VerifyInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyInviteCodeResponse userServiceVerifyInviteCode(String userId, UserServiceVerifyInviteCodeBody body) throws ApiException {
    return this.userServiceVerifyInviteCode(userId, body, Collections.emptyMap());
  }


  /**
   * Verify an invite code for a user
   * Verify the invite code of a user previously issued. This will set their email to a verified state and allow the user to set up their first authentication method (password, passkeys, IdP) depending on the organization&#39;s available methods.
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyInviteCodeResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyInviteCodeResponse userServiceVerifyInviteCode(String userId, UserServiceVerifyInviteCodeBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceVerifyInviteCode");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceVerifyInviteCode");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/invite_code/verify"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2VerifyInviteCodeResponse> localVarReturnType = new TypeReference<V2VerifyInviteCodeResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Verify a passkey for a user
   * Verify the passkey registration with the public key credential..
   * @param userId  (required)
   * @param passkeyId  (required)
   * @param body  (required)
   * @return V2VerifyPasskeyRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyPasskeyRegistrationResponse userServiceVerifyPasskeyRegistration(String userId, String passkeyId, UserServiceVerifyPasskeyRegistrationBody body) throws ApiException {
    return this.userServiceVerifyPasskeyRegistration(userId, passkeyId, body, Collections.emptyMap());
  }


  /**
   * Verify a passkey for a user
   * Verify the passkey registration with the public key credential..
   * @param userId  (required)
   * @param passkeyId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyPasskeyRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyPasskeyRegistrationResponse userServiceVerifyPasskeyRegistration(String userId, String passkeyId, UserServiceVerifyPasskeyRegistrationBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceVerifyPasskeyRegistration");
    }
    
    // verify the required parameter 'passkeyId' is set
    if (passkeyId == null) {
      throw new ApiException(400, "Missing the required parameter 'passkeyId' when calling userServiceVerifyPasskeyRegistration");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceVerifyPasskeyRegistration");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/passkeys/{passkeyId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "passkeyId" + "\\}", apiClient.escapeString(apiClient.parameterToString(passkeyId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2VerifyPasskeyRegistrationResponse> localVarReturnType = new TypeReference<V2VerifyPasskeyRegistrationResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Verify the phone
   * Verify the phone with the generated code..
   * @param userId  (required)
   * @param body  (required)
   * @return V2VerifyPhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyPhoneResponse userServiceVerifyPhone(String userId, UserServiceVerifyPhoneBody body) throws ApiException {
    return this.userServiceVerifyPhone(userId, body, Collections.emptyMap());
  }


  /**
   * Verify the phone
   * Verify the phone with the generated code..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyPhoneResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyPhoneResponse userServiceVerifyPhone(String userId, UserServiceVerifyPhoneBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceVerifyPhone");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceVerifyPhone");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/phone/verify"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2VerifyPhoneResponse> localVarReturnType = new TypeReference<V2VerifyPhoneResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Verify a TOTP generator for a user
   * Verify the TOTP registration with a generated code..
   * @param userId  (required)
   * @param body  (required)
   * @return V2VerifyTOTPRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyTOTPRegistrationResponse userServiceVerifyTOTPRegistration(String userId, UserServiceVerifyTOTPRegistrationBody body) throws ApiException {
    return this.userServiceVerifyTOTPRegistration(userId, body, Collections.emptyMap());
  }


  /**
   * Verify a TOTP generator for a user
   * Verify the TOTP registration with a generated code..
   * @param userId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyTOTPRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyTOTPRegistrationResponse userServiceVerifyTOTPRegistration(String userId, UserServiceVerifyTOTPRegistrationBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceVerifyTOTPRegistration");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceVerifyTOTPRegistration");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/totp/verify"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2VerifyTOTPRegistrationResponse> localVarReturnType = new TypeReference<V2VerifyTOTPRegistrationResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Verify a u2f token for a user
   * Verify the u2f token registration with the public key credential..
   * @param userId  (required)
   * @param u2fId  (required)
   * @param body  (required)
   * @return V2VerifyU2FRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyU2FRegistrationResponse userServiceVerifyU2FRegistration(String userId, String u2fId, UserServiceVerifyU2FRegistrationBody body) throws ApiException {
    return this.userServiceVerifyU2FRegistration(userId, u2fId, body, Collections.emptyMap());
  }


  /**
   * Verify a u2f token for a user
   * Verify the u2f token registration with the public key credential..
   * @param userId  (required)
   * @param u2fId  (required)
   * @param body  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return V2VerifyU2FRegistrationResponse
   * @throws ApiException if fails to make API call
   */
  public V2VerifyU2FRegistrationResponse userServiceVerifyU2FRegistration(String userId, String u2fId, UserServiceVerifyU2FRegistrationBody body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'userId' is set
    if (userId == null) {
      throw new ApiException(400, "Missing the required parameter 'userId' when calling userServiceVerifyU2FRegistration");
    }
    
    // verify the required parameter 'u2fId' is set
    if (u2fId == null) {
      throw new ApiException(400, "Missing the required parameter 'u2fId' when calling userServiceVerifyU2FRegistration");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling userServiceVerifyU2FRegistration");
    }
    
    // create path and map variables
    String localVarPath = "/v2/users/{userId}/u2f/{u2fId}"
      .replaceAll("\\{" + "userId" + "\\}", apiClient.escapeString(apiClient.parameterToString(userId)))
      .replaceAll("\\{" + "u2fId" + "\\}", apiClient.escapeString(apiClient.parameterToString(u2fId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    TypeReference<V2VerifyU2FRegistrationResponse> localVarReturnType = new TypeReference<V2VerifyU2FRegistrationResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  @Override
  public <T> T invokeAPI(String url, String method, Object request, TypeReference<T> returnType, Map<String, String> additionalHeaders) throws ApiException {
    String localVarPath = url.replace(apiClient.getBaseURL(), "");
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarHeaderParams.putAll(additionalHeaders);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "zitadelAccessToken" };

    return apiClient.invokeAPI(
      localVarPath,
        method,
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        request,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        returnType
    );
  }
}
